>Small systems are more likely to have small hardware and energy requirements, as well as high understandability. They are easier to understand, manage, refactor and repurpose.
>
>[permacomputing.net](https://permacomputing.net/Principles/)

- Low dependencies
- Avoid pseudosimplicity such as user interfaces that hide their operation from the user.
- **Accumulate wisdom and experience rather than codebase.**
- Low complexity is beautiful. This is also relevant to e.g. visual media where "high quality" is often thought to stem from high resolutions and large bitrates.
- [[Human-scale systems]]
- Scalability (upwards) is essential only if there is an actual and justifiable need to scale up; down-scalability may often be more relevant.
- Abundance thinking. If the computing capacity feels too limited for anything, you can rethink it from the point of view of abundance (e.g. by taking yourself fifty years back in time): tens of kilobytes of memory, thousands of operations per second â€“ think about all the possibilities!
